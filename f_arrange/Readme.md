### 全排列问题
全排列问题分为两种，一种是不含重复数字的全排列问题，一种是包含重复数字的全排列问题
#### 不包含重复数字的全排列问题
n个节点的全排列问题可以看成是一个由n个节点组成的一个强联通图的遍历问题，全排列的结果就是图的不同的遍历路径的结果。
#### 示例
例如数组位{1，2，3，4}

![GRAPH](https://github.com/jwwc/cplusplus/image/graph.png)

起点位1的情况有{1，2，3，4}，{1，2，4，3}，{1，3，2，4}，{1，3，4，2}，{1，4，2，3}，{1，4，3，2}

起点为2的有{2，1，3，4}，{2，1，4，3}，{2，3，1，4}，{2，3，4，1}，{2，4，，1，3}，{2，4，3，1}

起点为3和起点为4的遍历路径如上一样，所以就不再赘述

因此全排列问题可以有两种解决办法：bfs和dfs

为了减少空间复杂度，可以不用建图，可以通过遍历数组代替

源码[BFS](https://github.com/jwwc/cplusplus/f_arrange/BFS.cpp)
源码[DFS](https://github.com/jwwc/cplusplus/f_arrange/DFS.cpp)


#### 包含重复数字的全排列问题

包含重复数字的全排列问题的解题思路和不包含重复数字的全排列问题的解题思路一样，但是按照以上方法，就可能存在路径不同，但是遍历结果序列相同的情况，所有遍历得到结果需要去重,在BFS算法中去重方法是
每添加一条路径的时候，判断结果集中是否存在相同的路径序列，如果存在就不添加，DFS算法的去重方法为，对数组先进行排序，在遍历的时候，如果左边两边相邻的节点值和当前遍历到的节点值相同，且左边相邻的节点没有遍历过，则回退到上一层遍历。

源码[BFS_TWO.cpp](https://github.com/jwwc/cplusplus/f_arrange/BFS_TWO.cpp)
源码[DFS_TWO.cpp](https://github.com/jwwc/cplusplus/f_arrange/DFS_TWO.cpp)


***补充:*** 在BFS算法中，选用记录每一遍历节点的索引，代替记录遍历节点的值，因为索引是唯一的，加入结果集的时候，可以索引获取值进行转换。


